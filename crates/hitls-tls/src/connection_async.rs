//! Asynchronous TLS 1.3 connection wrapping an `AsyncRead + AsyncWrite` transport.

use tokio::io::{AsyncRead, AsyncReadExt, AsyncWrite, AsyncWriteExt};

use crate::config::TlsConfig;
use crate::connection::ConnectionState;
use crate::connection_info::ConnectionInfo;
use crate::crypt::key_schedule::KeySchedule;
use crate::crypt::traffic_keys::TrafficKeys;
use crate::crypt::{CipherSuiteParams, DigestVariant, NamedGroup};
use crate::handshake::client::{ClientHandshake, ServerHelloResult};
use crate::handshake::codec::{
    decode_certificate_request, decode_key_update, encode_certificate, encode_certificate_verify,
    encode_finished, encode_key_update, parse_handshake_header, CertificateEntry, CertificateMsg,
    CertificateVerifyMsg, KeyUpdateMsg, KeyUpdateRequest,
};
use crate::handshake::server::{ClientHelloResult, ServerHandshake};
use crate::handshake::{HandshakeState, HandshakeType};
use crate::record::{ContentType, RecordLayer};
use crate::session::TlsSession;
use crate::{AsyncTlsConnection, CipherSuite, TlsError, TlsVersion};
use hitls_crypto::provider::Digest;
use zeroize::Zeroize;

// ===========================================================================
// Async TLS 1.3 Client Connection
// ===========================================================================

/// An asynchronous TLS 1.3 client connection.
pub struct AsyncTlsClientConnection<S: AsyncRead + AsyncWrite + Unpin> {
    stream: S,
    config: TlsConfig,
    record_layer: RecordLayer,
    state: ConnectionState,
    negotiated_suite: Option<CipherSuite>,
    negotiated_version: Option<TlsVersion>,
    read_buf: Vec<u8>,
    app_data_buf: Vec<u8>,
    cipher_params: Option<CipherSuiteParams>,
    client_app_secret: Vec<u8>,
    server_app_secret: Vec<u8>,
    resumption_master_secret: Vec<u8>,
    exporter_master_secret: Vec<u8>,
    early_exporter_master_secret: Vec<u8>,
    client_hs: Option<ClientHandshake>,
    received_session: Option<TlsSession>,
    early_data_queue: Vec<u8>,
    early_data_accepted: bool,
    peer_certificates: Vec<Vec<u8>>,
    negotiated_alpn: Option<Vec<u8>>,
    server_name_used: Option<String>,
    negotiated_group: Option<NamedGroup>,
    session_resumed: bool,
    sent_close_notify: bool,
    received_close_notify: bool,
    /// Counter for consecutive KeyUpdate messages without application data.
    key_update_recv_count: u32,
}

impl<S: AsyncRead + AsyncWrite + Unpin> Drop for AsyncTlsClientConnection<S> {
    fn drop(&mut self) {
        self.client_app_secret.zeroize();
        self.server_app_secret.zeroize();
        self.resumption_master_secret.zeroize();
        self.exporter_master_secret.zeroize();
        self.early_exporter_master_secret.zeroize();
    }
}

// Non-I/O accessor methods generated by macro.
impl_tls13_client_accessors!(
    AsyncTlsClientConnection,
    ConnectionState,
    AsyncRead + AsyncWrite + Unpin
);

impl<S: AsyncRead + AsyncWrite + Unpin> AsyncTlsClientConnection<S> {
    /// Create a new async TLS client connection wrapping the given stream.
    pub fn new(stream: S, config: TlsConfig) -> Self {
        Self {
            stream,
            config,
            record_layer: RecordLayer::new(),
            state: ConnectionState::Handshaking,
            negotiated_suite: None,
            negotiated_version: None,
            read_buf: Vec::with_capacity(16 * 1024),
            app_data_buf: Vec::new(),
            cipher_params: None,
            client_app_secret: Vec::new(),
            server_app_secret: Vec::new(),
            resumption_master_secret: Vec::new(),
            exporter_master_secret: Vec::new(),
            early_exporter_master_secret: Vec::new(),
            client_hs: None,
            received_session: None,
            early_data_queue: Vec::new(),
            early_data_accepted: false,
            peer_certificates: Vec::new(),
            negotiated_alpn: None,
            server_name_used: None,
            negotiated_group: None,
            session_resumed: false,
            sent_close_notify: false,
            received_close_notify: false,
            key_update_recv_count: 0,
        }
    }

    async fn fill_buf(&mut self, min_bytes: usize) -> Result<(), TlsError> {
        fill_buf_body!(is_async, self, min_bytes)
    }

    async fn read_record(&mut self) -> Result<(ContentType, Vec<u8>), TlsError> {
        read_record_body!(is_async, self)
    }

    /// Initiate a key update (RFC 8446 §4.6.3).
    pub async fn key_update(&mut self, request_response: bool) -> Result<(), TlsError> {
        tls13_client_key_update_body!(is_async, self, request_response)
    }

    async fn handle_key_update(&mut self, body: &[u8]) -> Result<(), TlsError> {
        tls13_client_handle_key_update_body!(is_async, self, body)
    }

    async fn handle_post_hs_cert_request(
        &mut self,
        body: &[u8],
        full_msg: &[u8],
    ) -> Result<(), TlsError> {
        tls13_client_handle_post_hs_cert_request_body!(is_async, self, body, full_msg)
    }

    async fn do_handshake(&mut self) -> Result<(), TlsError> {
        tls13_client_do_handshake_body!(is_async, self)
    }

    async fn read_and_process_server_hello(
        &mut self,
        hs: &mut ClientHandshake,
    ) -> Result<crate::handshake::client::ServerHelloActions, TlsError> {
        tls13_client_read_and_process_server_hello_body!(is_async, self, hs)
    }

    async fn process_encrypted_flight(
        &mut self,
        hs: &mut ClientHandshake,
        offered_early_data: bool,
        hs_write_suite: CipherSuite,
        hs_write_keys: &TrafficKeys,
    ) -> Result<(), TlsError> {
        tls13_client_process_encrypted_flight_body!(
            is_async,
            self,
            hs,
            offered_early_data,
            hs_write_suite,
            hs_write_keys
        )
    }
}

impl<S: AsyncRead + AsyncWrite + Unpin> AsyncTlsConnection for AsyncTlsClientConnection<S> {
    async fn handshake(&mut self) -> Result<(), TlsError> {
        tls13_client_handshake_trait_body!(is_async, self)
    }

    async fn read(&mut self, buf: &mut [u8]) -> Result<usize, TlsError> {
        tls13_client_read_trait_body!(is_async, self, buf)
    }

    async fn write(&mut self, buf: &[u8]) -> Result<usize, TlsError> {
        tls_write_trait_body!(is_async, self, buf)
    }

    async fn shutdown(&mut self) -> Result<(), TlsError> {
        tls13_client_shutdown_trait_body!(is_async, self)
    }

    fn version(&self) -> Option<TlsVersion> {
        self.negotiated_version
    }

    fn cipher_suite(&self) -> Option<CipherSuite> {
        self.negotiated_suite
    }
}

// ===========================================================================
// Async TLS 1.3 Server Connection
// ===========================================================================

/// An asynchronous TLS 1.3 server connection.
pub struct AsyncTlsServerConnection<S: AsyncRead + AsyncWrite + Unpin> {
    stream: S,
    config: TlsConfig,
    record_layer: RecordLayer,
    state: ConnectionState,
    negotiated_suite: Option<CipherSuite>,
    negotiated_version: Option<TlsVersion>,
    read_buf: Vec<u8>,
    app_data_buf: Vec<u8>,
    cipher_params: Option<CipherSuiteParams>,
    client_app_secret: Vec<u8>,
    server_app_secret: Vec<u8>,
    exporter_master_secret: Vec<u8>,
    early_exporter_master_secret: Vec<u8>,
    peer_certificates: Vec<Vec<u8>>,
    negotiated_alpn: Option<Vec<u8>>,
    client_server_name: Option<String>,
    negotiated_group: Option<NamedGroup>,
    session_resumed: bool,
    sent_close_notify: bool,
    received_close_notify: bool,
    /// Counter for consecutive KeyUpdate messages without application data.
    key_update_recv_count: u32,
}

impl<S: AsyncRead + AsyncWrite + Unpin> Drop for AsyncTlsServerConnection<S> {
    fn drop(&mut self) {
        self.client_app_secret.zeroize();
        self.server_app_secret.zeroize();
        self.exporter_master_secret.zeroize();
        self.early_exporter_master_secret.zeroize();
    }
}

// Non-I/O accessor methods generated by macro.
impl_tls13_server_accessors!(
    AsyncTlsServerConnection,
    ConnectionState,
    client_server_name,
    AsyncRead + AsyncWrite + Unpin
);

impl<S: AsyncRead + AsyncWrite + Unpin> AsyncTlsServerConnection<S> {
    /// Create a new async TLS server connection wrapping the given stream.
    pub fn new(stream: S, config: TlsConfig) -> Self {
        Self {
            stream,
            config,
            record_layer: RecordLayer::new(),
            state: ConnectionState::Handshaking,
            negotiated_suite: None,
            negotiated_version: None,
            read_buf: Vec::with_capacity(16 * 1024),
            app_data_buf: Vec::new(),
            cipher_params: None,
            client_app_secret: Vec::new(),
            server_app_secret: Vec::new(),
            exporter_master_secret: Vec::new(),
            early_exporter_master_secret: Vec::new(),
            peer_certificates: Vec::new(),
            negotiated_alpn: None,
            client_server_name: None,
            negotiated_group: None,
            session_resumed: false,
            sent_close_notify: false,
            received_close_notify: false,
            key_update_recv_count: 0,
        }
    }

    async fn fill_buf(&mut self, min_bytes: usize) -> Result<(), TlsError> {
        fill_buf_body!(is_async, self, min_bytes)
    }

    async fn read_record(&mut self) -> Result<(ContentType, Vec<u8>), TlsError> {
        read_record_body!(is_async, self)
    }

    /// Initiate a key update (RFC 8446 §4.6.3).
    pub async fn key_update(&mut self, request_response: bool) -> Result<(), TlsError> {
        tls13_server_key_update_body!(is_async, self, request_response)
    }

    async fn handle_key_update(&mut self, body: &[u8]) -> Result<(), TlsError> {
        tls13_server_handle_key_update_body!(is_async, self, body)
    }

    async fn do_handshake(&mut self) -> Result<(), TlsError> {
        tls13_server_do_handshake_body!(is_async, self)
    }
}

impl<S: AsyncRead + AsyncWrite + Unpin> AsyncTlsConnection for AsyncTlsServerConnection<S> {
    async fn handshake(&mut self) -> Result<(), TlsError> {
        tls13_server_handshake_trait_body!(is_async, self)
    }

    async fn read(&mut self, buf: &mut [u8]) -> Result<usize, TlsError> {
        tls13_server_read_trait_body!(is_async, self, buf)
    }

    async fn write(&mut self, buf: &[u8]) -> Result<usize, TlsError> {
        tls_write_trait_body!(is_async, self, buf)
    }

    async fn shutdown(&mut self) -> Result<(), TlsError> {
        tls13_client_shutdown_trait_body!(is_async, self)
    }

    fn version(&self) -> Option<TlsVersion> {
        self.negotiated_version
    }

    fn cipher_suite(&self) -> Option<CipherSuite> {
        self.negotiated_suite
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_async_client_creation() {
        let (client, _server) = tokio::io::duplex(16 * 1024);
        let config = TlsConfig::builder().build();
        let conn = AsyncTlsClientConnection::new(client, config);
        assert_eq!(conn.state, ConnectionState::Handshaking);
        assert!(conn.version().is_none());
        assert!(conn.cipher_suite().is_none());
    }

    #[test]
    fn test_async_server_creation() {
        let (_client, server) = tokio::io::duplex(16 * 1024);
        let config = TlsConfig::builder().build();
        let conn = AsyncTlsServerConnection::new(server, config);
        assert_eq!(conn.state, ConnectionState::Handshaking);
        assert!(conn.version().is_none());
        assert!(conn.cipher_suite().is_none());
    }

    // -------------------------------------------------------
    // TLS 1.3 async unit tests
    // -------------------------------------------------------

    /// Build a matched (client_config, server_config) pair for TLS 1.3 async tests.
    /// Uses an Ed25519 key with a fake cert DER; verify_peer(false) so cert is not validated.
    fn make_tls13_configs() -> (TlsConfig, TlsConfig) {
        use crate::config::ServerPrivateKey;
        // Minimal ASN.1 SEQUENCE — accepted by TLS layer when verify_peer=false
        let fake_cert = vec![0x30, 0x82, 0x01, 0x00];
        // Valid 32-byte Ed25519 seed
        let seed = [0x42u8; 32];

        let server_config = TlsConfig::builder()
            .certificate_chain(vec![fake_cert])
            .private_key(ServerPrivateKey::Ed25519(seed.to_vec()))
            .verify_peer(false)
            .build();

        let client_config = TlsConfig::builder().verify_peer(false).build();

        (client_config, server_config)
    }

    #[tokio::test]
    async fn test_async_tls13_read_before_handshake() {
        let (_, server_config) = make_tls13_configs();
        let (_, server_stream) = tokio::io::duplex(16 * 1024);
        let mut conn = AsyncTlsServerConnection::new(server_stream, server_config);

        let mut buf = [0u8; 16];
        let result = conn.read(&mut buf).await;
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_async_tls13_write_before_handshake() {
        let (client_config, _) = make_tls13_configs();
        let (client_stream, _) = tokio::io::duplex(16 * 1024);
        let mut conn = AsyncTlsClientConnection::new(client_stream, client_config);

        let result = conn.write(b"hello").await;
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_async_tls13_full_handshake_and_data() {
        let (client_config, server_config) = make_tls13_configs();
        let (client_stream, server_stream) = tokio::io::duplex(64 * 1024);

        let mut client = AsyncTlsClientConnection::new(client_stream, client_config);
        let mut server = AsyncTlsServerConnection::new(server_stream, server_config);

        let (c_res, s_res) = tokio::join!(client.handshake(), server.handshake());
        c_res.unwrap();
        s_res.unwrap();

        // Client → Server
        let msg = b"Hello TLS 1.3 async!";
        client.write(msg).await.unwrap();
        let mut buf = [0u8; 256];
        let n = server.read(&mut buf).await.unwrap();
        assert_eq!(&buf[..n], msg);

        // Server → Client
        let reply = b"TLS 1.3 async reply!";
        server.write(reply).await.unwrap();
        let n = client.read(&mut buf).await.unwrap();
        assert_eq!(&buf[..n], reply);
    }

    #[tokio::test]
    async fn test_async_tls13_version_and_cipher() {
        let (client_config, server_config) = make_tls13_configs();
        let (client_stream, server_stream) = tokio::io::duplex(64 * 1024);

        let mut client = AsyncTlsClientConnection::new(client_stream, client_config);
        let mut server = AsyncTlsServerConnection::new(server_stream, server_config);

        let (c_res, s_res) = tokio::join!(client.handshake(), server.handshake());
        c_res.unwrap();
        s_res.unwrap();

        assert_eq!(client.version(), Some(TlsVersion::Tls13));
        assert_eq!(server.version(), Some(TlsVersion::Tls13));
        assert!(client.cipher_suite().is_some());
        assert!(server.cipher_suite().is_some());
    }

    #[tokio::test]
    async fn test_async_tls13_shutdown() {
        let (client_config, server_config) = make_tls13_configs();
        let (client_stream, server_stream) = tokio::io::duplex(64 * 1024);

        let mut client = AsyncTlsClientConnection::new(client_stream, client_config);
        let mut server = AsyncTlsServerConnection::new(server_stream, server_config);

        let (c_res, s_res) = tokio::join!(client.handshake(), server.handshake());
        c_res.unwrap();
        s_res.unwrap();

        client.shutdown().await.unwrap();
        // Double shutdown should succeed
        client.shutdown().await.unwrap();
    }

    #[tokio::test]
    async fn test_async_tls13_large_payload() {
        let (client_config, server_config) = make_tls13_configs();
        let (client_stream, server_stream) = tokio::io::duplex(128 * 1024);

        let mut client = AsyncTlsClientConnection::new(client_stream, client_config);
        let mut server = AsyncTlsServerConnection::new(server_stream, server_config);

        let (c_res, s_res) = tokio::join!(client.handshake(), server.handshake());
        c_res.unwrap();
        s_res.unwrap();

        // 32 KB payload — crosses the 16 KB TLS record boundary
        let payload = vec![0xABu8; 32 * 1024];
        client.write(&payload).await.unwrap();

        let mut received = Vec::new();
        while received.len() < payload.len() {
            let mut buf = [0u8; 16 * 1024];
            let n = server.read(&mut buf).await.unwrap();
            received.extend_from_slice(&buf[..n]);
        }
        assert_eq!(received, payload);
    }

    #[tokio::test]
    async fn test_async_tls13_multi_message() {
        let (client_config, server_config) = make_tls13_configs();
        let (client_stream, server_stream) = tokio::io::duplex(64 * 1024);

        let mut client = AsyncTlsClientConnection::new(client_stream, client_config);
        let mut server = AsyncTlsServerConnection::new(server_stream, server_config);

        let (c_res, s_res) = tokio::join!(client.handshake(), server.handshake());
        c_res.unwrap();
        s_res.unwrap();

        let messages: &[&[u8]] = &[b"msg-one", b"msg-two", b"msg-three"];
        for msg in messages {
            client.write(msg).await.unwrap();
            let mut buf = [0u8; 256];
            let n = server.read(&mut buf).await.unwrap();
            assert_eq!(&buf[..n], *msg);
        }
    }

    #[tokio::test]
    async fn test_async_tls13_key_update() {
        let (client_config, server_config) = make_tls13_configs();
        let (client_stream, server_stream) = tokio::io::duplex(64 * 1024);

        let mut client = AsyncTlsClientConnection::new(client_stream, client_config);
        let mut server = AsyncTlsServerConnection::new(server_stream, server_config);

        let (c_res, s_res) = tokio::join!(client.handshake(), server.handshake());
        c_res.unwrap();
        s_res.unwrap();

        // Key update without requesting peer response
        client.key_update(false).await.unwrap();

        // Data exchange still works after key update
        client.write(b"after key update").await.unwrap();
        let mut buf = [0u8; 256];
        let n = server.read(&mut buf).await.unwrap();
        assert_eq!(&buf[..n], b"after key update");
    }

    #[tokio::test]
    async fn test_async_tls13_session_take() {
        let (client_config, server_config) = make_tls13_configs();
        let (client_stream, server_stream) = tokio::io::duplex(64 * 1024);

        let mut client = AsyncTlsClientConnection::new(client_stream, client_config);
        let mut server = AsyncTlsServerConnection::new(server_stream, server_config);

        let (c_res, s_res) = tokio::join!(client.handshake(), server.handshake());
        c_res.unwrap();
        s_res.unwrap();

        // The client may receive a NewSessionTicket — take it if present
        let session = client.take_session();
        // In TLS 1.3, session is only populated after NST reception.
        // Whether Some or None, take_session() must not panic.
        let _ = session;

        // Second take always returns None
        assert!(client.take_session().is_none());
    }

    #[tokio::test]
    async fn test_async_tls13_connection_info() {
        let (client_config, server_config) = make_tls13_configs();
        let (client_stream, server_stream) = tokio::io::duplex(64 * 1024);

        let mut client = AsyncTlsClientConnection::new(client_stream, client_config);
        let mut server = AsyncTlsServerConnection::new(server_stream, server_config);

        let (c_res, s_res) = tokio::join!(client.handshake(), server.handshake());
        c_res.unwrap();
        s_res.unwrap();

        let info = client.connection_info();
        assert!(info.is_some());
        let info = info.unwrap();
        // cipher_suite is populated after a successful TLS 1.3 handshake
        assert_eq!(info.cipher_suite, client.cipher_suite().unwrap());
    }

    #[tokio::test]
    async fn test_async_tls13_alpn_negotiation() {
        use crate::config::ServerPrivateKey;
        let fake_cert = vec![0x30, 0x82, 0x01, 0x00];
        let seed = [0x43u8; 32];

        let server_config = TlsConfig::builder()
            .certificate_chain(vec![fake_cert])
            .private_key(ServerPrivateKey::Ed25519(seed.to_vec()))
            .verify_peer(false)
            .alpn(&[b"h2", b"http/1.1"])
            .build();

        let client_config = TlsConfig::builder()
            .verify_peer(false)
            .alpn(&[b"h2"])
            .build();

        let (client_stream, server_stream) = tokio::io::duplex(64 * 1024);
        let mut client = AsyncTlsClientConnection::new(client_stream, client_config);
        let mut server = AsyncTlsServerConnection::new(server_stream, server_config);

        let (c_res, s_res) = tokio::join!(client.handshake(), server.handshake());
        c_res.unwrap();
        s_res.unwrap();

        let info = client.connection_info().unwrap();
        assert_eq!(info.alpn_protocol.as_deref(), Some(b"h2".as_ref()));
    }

    #[tokio::test]
    async fn test_async_tls13_is_session_resumed() {
        let (client_config, server_config) = make_tls13_configs();
        let (client_stream, server_stream) = tokio::io::duplex(64 * 1024);

        let mut client = AsyncTlsClientConnection::new(client_stream, client_config);
        let mut server = AsyncTlsServerConnection::new(server_stream, server_config);

        let (c_res, s_res) = tokio::join!(client.handshake(), server.handshake());
        c_res.unwrap();
        s_res.unwrap();

        // Full handshake — not a resumed session
        assert!(!client.is_session_resumed());
        assert!(!server.is_session_resumed());
    }

    // -------------------------------------------------------
    // Testing-Phase 75 — E2: Async export API unit tests
    // -------------------------------------------------------

    /// export_keying_material returns error when called before handshake.
    #[tokio::test]
    async fn test_async_tls13_export_keying_material_before_handshake() {
        let (client_stream, _server_stream) = tokio::io::duplex(64 * 1024);
        let config = TlsConfig::builder().verify_peer(false).build();
        let conn = AsyncTlsClientConnection::new(client_stream, config);

        let result = conn.export_keying_material(b"label", None, 32);
        assert!(result.is_err(), "must fail before handshake");
        let msg = format!("{}", result.unwrap_err());
        assert!(msg.contains("not connected"), "error: {msg}");
    }

    /// export_early_keying_material returns error when no PSK was offered.
    #[tokio::test]
    async fn test_async_tls13_export_early_keying_material_no_psk() {
        let (client_config, server_config) = make_tls13_configs();
        let (client_stream, server_stream) = tokio::io::duplex(64 * 1024);

        let mut client = AsyncTlsClientConnection::new(client_stream, client_config);
        let mut server = AsyncTlsServerConnection::new(server_stream, server_config);

        let (c_res, s_res) = tokio::join!(client.handshake(), server.handshake());
        c_res.unwrap();
        s_res.unwrap();

        // No PSK → early exporter master secret is empty
        let c_result = client.export_early_keying_material(b"early label", None, 32);
        assert!(
            c_result.is_err(),
            "client: early export must fail without PSK"
        );
        let msg = format!("{}", c_result.unwrap_err());
        assert!(
            msg.contains("no early exporter master secret"),
            "unexpected error: {msg}"
        );

        let s_result = server.export_early_keying_material(b"early label", None, 32);
        assert!(
            s_result.is_err(),
            "server: early export must fail without PSK"
        );
    }

    /// export_keying_material: client and server derive identical keying material.
    #[tokio::test]
    async fn test_async_tls13_export_keying_material_both_sides() {
        let (client_config, server_config) = make_tls13_configs();
        let (client_stream, server_stream) = tokio::io::duplex(64 * 1024);

        let mut client = AsyncTlsClientConnection::new(client_stream, client_config);
        let mut server = AsyncTlsServerConnection::new(server_stream, server_config);

        let (c_res, s_res) = tokio::join!(client.handshake(), server.handshake());
        c_res.unwrap();
        s_res.unwrap();

        let label = b"ASYNC EXPORTER";
        let context = Some(b"async context".as_ref());

        let client_ekm = client.export_keying_material(label, context, 32).unwrap();
        let server_ekm = server.export_keying_material(label, context, 32).unwrap();

        assert_eq!(client_ekm.len(), 32);
        assert_eq!(server_ekm.len(), 32);
        assert_eq!(
            client_ekm, server_ekm,
            "async client and server must derive identical keying material"
        );
    }

    /// export_keying_material: different labels produce different material.
    #[tokio::test]
    async fn test_async_tls13_export_keying_material_different_labels() {
        let (client_config, server_config) = make_tls13_configs();
        let (client_stream, server_stream) = tokio::io::duplex(64 * 1024);

        let mut client = AsyncTlsClientConnection::new(client_stream, client_config);
        let mut server = AsyncTlsServerConnection::new(server_stream, server_config);

        let (c_res, s_res) = tokio::join!(client.handshake(), server.handshake());
        c_res.unwrap();
        s_res.unwrap();

        let ekm_a = client.export_keying_material(b"LABEL A", None, 32).unwrap();
        let ekm_b = client.export_keying_material(b"LABEL B", None, 32).unwrap();
        let ekm_a_ctx = client
            .export_keying_material(b"LABEL A", Some(b"ctx"), 32)
            .unwrap();

        assert_ne!(ekm_a, ekm_b, "different labels must produce different EKM");
        assert_ne!(ekm_a, ekm_a_ctx, "no-context vs with-context must differ");

        // Server derives the same as client for each case
        let s_ekm_a = server.export_keying_material(b"LABEL A", None, 32).unwrap();
        assert_eq!(ekm_a, s_ekm_a, "server EKM for LABEL A must match client");
    }

    /// certificate_authorities config: handshake succeeds with or without CAs configured.
    #[tokio::test]
    async fn test_async_tls13_certificate_authorities_config() {
        use crate::config::ServerPrivateKey;

        let fake_cert = vec![0x30, 0x82, 0x01, 0x00];
        let seed = [0x42u8; 32];

        let server_config = TlsConfig::builder()
            .certificate_chain(vec![fake_cert])
            .private_key(ServerPrivateKey::Ed25519(seed.to_vec()))
            .verify_peer(false)
            .build();

        // Client with non-empty certificate_authorities list
        let dn1 = vec![0x30, 0x07, 0x31, 0x05, 0x30, 0x03, 0x06, 0x01, 0x41];
        let client_config = TlsConfig::builder()
            .verify_peer(false)
            .certificate_authorities(vec![dn1])
            .build();

        let (client_stream, server_stream) = tokio::io::duplex(64 * 1024);
        let mut client = AsyncTlsClientConnection::new(client_stream, client_config);
        let mut server = AsyncTlsServerConnection::new(server_stream, server_config);

        let (c_res, s_res) = tokio::join!(client.handshake(), server.handshake());
        c_res.unwrap();
        s_res.unwrap();

        // After handshake, export must succeed
        let ekm = client.export_keying_material(b"label", None, 16).unwrap();
        assert_eq!(ekm.len(), 16);
    }

    /// key_update with request_response=true triggers bidirectional key rotation.
    #[tokio::test]
    async fn test_async_tls13_key_update_request_response() {
        let (client_config, server_config) = make_tls13_configs();
        let (client_stream, server_stream) = tokio::io::duplex(64 * 1024);

        let mut client = AsyncTlsClientConnection::new(client_stream, client_config);
        let mut server = AsyncTlsServerConnection::new(server_stream, server_config);

        let (c_res, s_res) = tokio::join!(client.handshake(), server.handshake());
        c_res.unwrap();
        s_res.unwrap();

        // Key update requesting peer response
        client.key_update(true).await.unwrap();

        // Data exchange still works after key update request
        client.write(b"after request response").await.unwrap();
        let mut buf = [0u8; 256];
        let n = server.read(&mut buf).await.unwrap();
        assert_eq!(&buf[..n], b"after request response");
    }

    /// export_keying_material with zero length output.
    #[tokio::test]
    async fn test_async_tls13_export_keying_material_zero_length() {
        let (client_config, server_config) = make_tls13_configs();
        let (client_stream, server_stream) = tokio::io::duplex(64 * 1024);

        let mut client = AsyncTlsClientConnection::new(client_stream, client_config);
        let mut server = AsyncTlsServerConnection::new(server_stream, server_config);

        let (c_res, s_res) = tokio::join!(client.handshake(), server.handshake());
        c_res.unwrap();
        s_res.unwrap();

        let ekm = client.export_keying_material(b"zero-len", None, 0).unwrap();
        assert!(ekm.is_empty());
    }

    /// Server-side export_keying_material before handshake returns error.
    #[tokio::test]
    async fn test_async_tls13_server_export_before_handshake() {
        let (_, server_config) = make_tls13_configs();
        let (_, server_stream) = tokio::io::duplex(16 * 1024);
        let server = AsyncTlsServerConnection::new(server_stream, server_config);

        let result = server.export_keying_material(b"test", None, 32);
        assert!(result.is_err());
    }

    /// Accessor methods return expected values after handshake.
    #[tokio::test]
    async fn test_async_tls13_accessor_methods() {
        let (client_config, server_config) = make_tls13_configs();
        let (client_stream, server_stream) = tokio::io::duplex(64 * 1024);

        let mut client = AsyncTlsClientConnection::new(client_stream, client_config);
        let mut server = AsyncTlsServerConnection::new(server_stream, server_config);

        let (c_res, s_res) = tokio::join!(client.handshake(), server.handshake());
        c_res.unwrap();
        s_res.unwrap();

        // peer_certificates: server doesn't verify peer, so client certs should be empty
        assert!(server.peer_certificates().is_empty());
        // server_name: client didn't set server_name
        assert!(client.server_name().is_none());
        // negotiated_group: should be set after handshake
        assert!(client.negotiated_group().is_some());
        // connection_info should be available
        assert!(client.connection_info().is_some());
        assert!(server.connection_info().is_some());
    }

    /// export_keying_material: different contexts produce different results.
    #[tokio::test]
    async fn test_async_tls13_export_different_contexts() {
        let (client_config, server_config) = make_tls13_configs();
        let (client_stream, server_stream) = tokio::io::duplex(64 * 1024);

        let mut client = AsyncTlsClientConnection::new(client_stream, client_config);
        let mut server = AsyncTlsServerConnection::new(server_stream, server_config);

        let (c_res, s_res) = tokio::join!(client.handshake(), server.handshake());
        c_res.unwrap();
        s_res.unwrap();

        let ctx_a = client
            .export_keying_material(b"test-label", Some(b"context-A"), 32)
            .unwrap();
        let ctx_b = client
            .export_keying_material(b"test-label", Some(b"context-B"), 32)
            .unwrap();
        assert_ne!(
            ctx_a, ctx_b,
            "different contexts should produce different output"
        );
    }

    /// export_keying_material: deterministic — same call returns same bytes.
    #[tokio::test]
    async fn test_async_tls13_export_keying_material_deterministic() {
        let (client_config, server_config) = make_tls13_configs();
        let (client_stream, server_stream) = tokio::io::duplex(64 * 1024);

        let mut client = AsyncTlsClientConnection::new(client_stream, client_config);
        let mut server = AsyncTlsServerConnection::new(server_stream, server_config);

        let (c_res, s_res) = tokio::join!(client.handshake(), server.handshake());
        c_res.unwrap();
        s_res.unwrap();

        // Same label + context → same output (deterministic HKDF-Expand)
        let ekm1 = client
            .export_keying_material(b"STABLE LABEL", Some(b"ctx"), 32)
            .unwrap();
        let ekm2 = client
            .export_keying_material(b"STABLE LABEL", Some(b"ctx"), 32)
            .unwrap();
        assert_eq!(ekm1, ekm2, "export_keying_material must be deterministic");

        // Server also deterministic and matches client
        let s_ekm1 = server
            .export_keying_material(b"STABLE LABEL", Some(b"ctx"), 32)
            .unwrap();
        assert_eq!(ekm1, s_ekm1, "server export must match client");
    }

    // ===================================================================
    // Async 0-RTT Early Data tests (Testing-Phase 91)
    // ===================================================================

    fn make_tls13_early_data_configs(max_early_data_size: u32) -> (TlsConfig, TlsConfig, Vec<u8>) {
        use crate::config::ServerPrivateKey;
        let fake_cert = vec![0x30, 0x82, 0x01, 0x00];
        let seed = [0x42u8; 32];
        let ticket_key = vec![0xAB; 32];

        let server_config = TlsConfig::builder()
            .certificate_chain(vec![fake_cert])
            .private_key(ServerPrivateKey::Ed25519(seed.to_vec()))
            .verify_peer(false)
            .ticket_key(ticket_key.clone())
            .max_early_data_size(max_early_data_size)
            .build();

        let client_config = TlsConfig::builder().verify_peer(false).build();

        (client_config, server_config, ticket_key)
    }

    /// Async 0-RTT: queue early data, server accepts, data received correctly.
    #[tokio::test]
    async fn test_async_tls13_early_data_accepted() {
        // Step 1: initial handshake to get session with max_early_data
        let (client_config, server_config, ticket_key) = make_tls13_early_data_configs(16384);
        let (client_stream, server_stream) = tokio::io::duplex(64 * 1024);

        let mut client = AsyncTlsClientConnection::new(client_stream, client_config);
        let mut server = AsyncTlsServerConnection::new(server_stream, server_config);

        let (c_res, s_res) = tokio::join!(client.handshake(), server.handshake());
        c_res.unwrap();
        s_res.unwrap();

        // Exchange data to trigger NST delivery
        client.write(b"trigger nst").await.unwrap();
        let mut buf = [0u8; 256];
        let _ = server.read(&mut buf).await.unwrap();
        server.write(b"ack").await.unwrap();
        let _ = client.read(&mut buf).await.unwrap();

        let session = client
            .take_session()
            .expect("should have received session ticket");
        assert!(
            session.max_early_data > 0,
            "session should allow early data"
        );

        // Step 2: resumption handshake with 0-RTT
        let client_config2 = TlsConfig::builder()
            .verify_peer(false)
            .resumption_session(session)
            .max_early_data_size(16384)
            .build();
        let server_config2 = {
            use crate::config::ServerPrivateKey;
            let fake_cert = vec![0x30, 0x82, 0x01, 0x00];
            let seed = [0x42u8; 32];
            TlsConfig::builder()
                .certificate_chain(vec![fake_cert])
                .private_key(ServerPrivateKey::Ed25519(seed.to_vec()))
                .verify_peer(false)
                .ticket_key(ticket_key)
                .max_early_data_size(16384)
                .build()
        };

        let (client_stream2, server_stream2) = tokio::io::duplex(64 * 1024);
        let mut client2 = AsyncTlsClientConnection::new(client_stream2, client_config2);
        let mut server2 = AsyncTlsServerConnection::new(server_stream2, server_config2);

        // Queue early data before handshake
        client2.queue_early_data(b"0-RTT async hello");
        assert!(!client2.early_data_accepted()); // not yet

        let (c_res2, s_res2) = tokio::join!(client2.handshake(), server2.handshake());
        c_res2.unwrap();
        s_res2.unwrap();

        assert!(client2.early_data_accepted(), "server should accept 0-RTT");

        // Server receives early data first (buffered during handshake)
        let n = server2.read(&mut buf).await.unwrap();
        assert_eq!(
            &buf[..n],
            b"0-RTT async hello",
            "server should receive early data"
        );

        // Post-handshake data exchange still works
        client2.write(b"post-0rtt").await.unwrap();
        let n = server2.read(&mut buf).await.unwrap();
        assert_eq!(&buf[..n], b"post-0rtt");
    }

    /// Async 0-RTT: server rejects early data, handshake still completes.
    #[tokio::test]
    async fn test_async_tls13_early_data_rejected() {
        // Step 1: initial handshake with max_early_data > 0
        let (client_config, server_config, ticket_key) = make_tls13_early_data_configs(16384);
        let (client_stream, server_stream) = tokio::io::duplex(64 * 1024);

        let mut client = AsyncTlsClientConnection::new(client_stream, client_config);
        let mut server = AsyncTlsServerConnection::new(server_stream, server_config);

        let (c_res, s_res) = tokio::join!(client.handshake(), server.handshake());
        c_res.unwrap();
        s_res.unwrap();

        client.write(b"trigger").await.unwrap();
        let mut buf = [0u8; 256];
        let _ = server.read(&mut buf).await.unwrap();
        server.write(b"ack").await.unwrap();
        let _ = client.read(&mut buf).await.unwrap();

        let session = client.take_session().expect("should have session");

        // Step 2: resumption with server max_early_data_size=0 (reject)
        let client_config2 = TlsConfig::builder()
            .verify_peer(false)
            .resumption_session(session)
            .max_early_data_size(16384)
            .build();
        let server_config2 = {
            use crate::config::ServerPrivateKey;
            let fake_cert = vec![0x30, 0x82, 0x01, 0x00];
            let seed = [0x42u8; 32];
            TlsConfig::builder()
                .certificate_chain(vec![fake_cert])
                .private_key(ServerPrivateKey::Ed25519(seed.to_vec()))
                .verify_peer(false)
                .ticket_key(ticket_key)
                .max_early_data_size(0) // reject
                .build()
        };

        let (client_stream2, server_stream2) = tokio::io::duplex(64 * 1024);
        let mut client2 = AsyncTlsClientConnection::new(client_stream2, client_config2);
        let mut server2 = AsyncTlsServerConnection::new(server_stream2, server_config2);

        // Don't queue early data — just verify the rejection flag.
        // (If early data were sent, server can't decrypt it since it lacks
        // early read keys when rejecting, matching RFC 8446 §4.2.10.)

        let (c_res2, s_res2) = tokio::join!(client2.handshake(), server2.handshake());
        c_res2.unwrap();
        s_res2.unwrap();

        assert!(!client2.early_data_accepted(), "server should reject 0-RTT");

        // 1-RTT data exchange works normally
        client2.write(b"fallback 1rtt").await.unwrap();
        let n = server2.read(&mut buf).await.unwrap();
        assert_eq!(&buf[..n], b"fallback 1rtt");
    }

    /// Async 0-RTT: queue_early_data API and early_data_accepted before handshake.
    #[tokio::test]
    async fn test_async_tls13_queue_early_data_api() {
        let (client_config, _) = make_tls13_configs();
        let (client_stream, _) = tokio::io::duplex(16 * 1024);
        let mut conn = AsyncTlsClientConnection::new(client_stream, client_config);

        assert!(!conn.early_data_accepted());
        conn.queue_early_data(b"hello");
        conn.queue_early_data(b" world");
        assert!(!conn.early_data_accepted());
        // Queue should accumulate
        assert_eq!(conn.early_data_queue, b"hello world");
    }
}
