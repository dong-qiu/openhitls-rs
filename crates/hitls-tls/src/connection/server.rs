use std::io::{Read, Write};

use super::ConnectionState;
use crate::config::TlsConfig;
use crate::connection_info::ConnectionInfo;
use crate::crypt::key_schedule::KeySchedule;
use crate::crypt::traffic_keys::TrafficKeys;
use crate::crypt::{CipherSuiteParams, DigestVariant, NamedGroup};
use crate::handshake::codec::{
    decode_certificate, decode_certificate_verify, decode_finished, decode_key_update,
    encode_certificate_request, encode_key_update, parse_handshake_header, CertificateRequestMsg,
    KeyUpdateMsg, KeyUpdateRequest,
};
use crate::handshake::server::{ClientHelloResult, ServerHandshake};
use crate::handshake::HandshakeType;
use crate::record::{ContentType, RecordLayer};
use crate::{CipherSuite, TlsConnection, TlsError, TlsVersion};
use hitls_crypto::provider::Digest;
use zeroize::Zeroize;

/// A synchronous TLS 1.3 server connection.
pub struct TlsServerConnection<S: Read + Write> {
    stream: S,
    config: TlsConfig,
    record_layer: RecordLayer,
    pub(super) state: ConnectionState,
    negotiated_suite: Option<CipherSuite>,
    negotiated_version: Option<TlsVersion>,
    read_buf: Vec<u8>,
    app_data_buf: Vec<u8>,
    /// Cipher suite parameters (for key updates).
    cipher_params: Option<CipherSuiteParams>,
    /// Client application traffic secret (for key updates).
    client_app_secret: Vec<u8>,
    /// Server application traffic secret (for key updates).
    server_app_secret: Vec<u8>,
    /// Exporter master secret (for RFC 5705 / RFC 8446 §7.5 key material export).
    exporter_master_secret: Vec<u8>,
    /// Early exporter master secret (for 0-RTT key material export, empty if no PSK).
    early_exporter_master_secret: Vec<u8>,
    /// Peer certificates (DER-encoded, leaf first).
    peer_certificates: Vec<Vec<u8>>,
    /// Negotiated ALPN protocol (if any).
    negotiated_alpn: Option<Vec<u8>>,
    /// Client server name (SNI) received from the client.
    client_server_name: Option<String>,
    /// Negotiated key exchange group (if applicable).
    negotiated_group: Option<NamedGroup>,
    /// Whether this connection was resumed from a previous session.
    session_resumed: bool,
    /// Whether we have sent close_notify.
    sent_close_notify: bool,
    /// Whether we have received close_notify.
    received_close_notify: bool,
    /// Counter for consecutive KeyUpdate messages without application data.
    pub(super) key_update_recv_count: u32,
}

impl<S: Read + Write> Drop for TlsServerConnection<S> {
    fn drop(&mut self) {
        self.client_app_secret.zeroize();
        self.server_app_secret.zeroize();
        self.exporter_master_secret.zeroize();
        self.early_exporter_master_secret.zeroize();
    }
}

// Non-I/O accessor methods generated by macro.
impl_tls13_server_accessors!(
    TlsServerConnection,
    ConnectionState,
    client_server_name,
    Read + Write
);

impl<S: Read + Write> TlsServerConnection<S> {
    /// Create a new TLS server connection wrapping the given stream.
    pub fn new(stream: S, config: TlsConfig) -> Self {
        Self {
            stream,
            config,
            record_layer: RecordLayer::new(),
            state: ConnectionState::Handshaking,
            negotiated_suite: None,
            negotiated_version: None,
            read_buf: Vec::with_capacity(16 * 1024),
            app_data_buf: Vec::new(),
            cipher_params: None,
            client_app_secret: Vec::new(),
            server_app_secret: Vec::new(),
            exporter_master_secret: Vec::new(),
            early_exporter_master_secret: Vec::new(),
            peer_certificates: Vec::new(),
            negotiated_alpn: None,
            client_server_name: None,
            negotiated_group: None,
            session_resumed: false,
            sent_close_notify: false,
            received_close_notify: false,
            key_update_recv_count: 0,
        }
    }

    fn fill_buf(&mut self, min_bytes: usize) -> Result<(), TlsError> {
        fill_buf_body!(sync, self, min_bytes)
    }

    fn read_record(&mut self) -> Result<(ContentType, Vec<u8>), TlsError> {
        read_record_body!(sync, self)
    }

    /// Initiate a key update (RFC 8446 §4.6.3).
    pub fn key_update(&mut self, request_response: bool) -> Result<(), TlsError> {
        tls13_server_key_update_body!(sync, self, request_response)
    }

    fn handle_key_update(&mut self, body: &[u8]) -> Result<(), TlsError> {
        tls13_server_handle_key_update_body!(sync, self, body)
    }

    /// Request post-handshake client authentication (RFC 8446 §4.6.2).
    ///
    /// Sends a CertificateRequest message and reads the client's
    /// Certificate + CertificateVerify + Finished response.
    /// Returns the client's certificate chain (DER-encoded certs), which
    /// may be empty if the client has no certificate.
    pub fn request_client_auth(&mut self) -> Result<Vec<Vec<u8>>, TlsError> {
        use crate::crypt::SignatureScheme;
        use crate::handshake::extensions_codec::build_signature_algorithms;
        use crate::handshake::verify::verify_certificate_verify;

        if self.state != ConnectionState::Connected {
            return Err(TlsError::HandshakeFailed(
                "request_client_auth: not connected".into(),
            ));
        }

        let params = self
            .cipher_params
            .as_ref()
            .ok_or_else(|| TlsError::HandshakeFailed("no cipher params".into()))?
            .clone();
        let alg = params.hash_alg_id();
        let ks = KeySchedule::new(params.clone());

        // Generate random context for this request
        let mut context = vec![0u8; 8];
        getrandom::getrandom(&mut context)
            .map_err(|e| TlsError::HandshakeFailed(format!("random error: {e}")))?;

        // Build CertificateRequest with signature_algorithms extension
        let sig_algs = vec![
            SignatureScheme::ED25519,
            SignatureScheme::ECDSA_SECP256R1_SHA256,
            SignatureScheme::ECDSA_SECP384R1_SHA384,
            SignatureScheme::RSA_PSS_RSAE_SHA256,
            SignatureScheme::RSA_PSS_RSAE_SHA384,
            SignatureScheme::RSA_PSS_RSAE_SHA512,
        ];
        let mut cr_exts = vec![build_signature_algorithms(&sig_algs)];
        if !self.config.oid_filters.is_empty() {
            cr_exts.push(crate::handshake::extensions_codec::build_oid_filters(
                &self.config.oid_filters,
            ));
        }
        let cr = CertificateRequestMsg {
            certificate_request_context: context.clone(),
            extensions: cr_exts,
        };
        let cr_msg = encode_certificate_request(&cr);

        // Send CertificateRequest
        let cr_record = self
            .record_layer
            .seal_record(ContentType::Handshake, &cr_msg)?;
        self.stream
            .write_all(&cr_record)
            .map_err(|e| TlsError::RecordError(format!("write error: {e}")))?;

        // Start transcript for this post-HS exchange (just the CertificateRequest)
        let mut hasher = DigestVariant::new(alg);
        hasher.update(&cr_msg).map_err(TlsError::CryptoError)?;

        // Read client Certificate
        let (ct, cert_data) = self.read_record()?;
        if ct != ContentType::Handshake {
            return Err(TlsError::HandshakeFailed(format!(
                "expected Handshake (Certificate), got {ct:?}"
            )));
        }
        let (hs_type, cert_body, cert_total) = parse_handshake_header(&cert_data)?;
        if hs_type != HandshakeType::Certificate {
            return Err(TlsError::HandshakeFailed(format!(
                "expected Certificate, got {hs_type:?}"
            )));
        }
        let cert_msg_data = &cert_data[..cert_total];
        let cert_msg = decode_certificate(cert_body)?;

        // Verify context matches
        if cert_msg.certificate_request_context != context {
            return Err(TlsError::HandshakeFailed(
                "certificate_request_context mismatch".into(),
            ));
        }

        let client_certs: Vec<Vec<u8>> = cert_msg
            .certificate_list
            .iter()
            .map(|e| e.cert_data.clone())
            .collect();

        // Update transcript with Certificate
        hasher
            .update(cert_msg_data)
            .map_err(TlsError::CryptoError)?;

        if client_certs.is_empty() {
            // Client sent empty Certificate — no CertificateVerify expected.
            // Read Finished.
            let mut fin_hash_buf = vec![0u8; params.hash_len];
            let mut hasher_fin = DigestVariant::new(alg);
            hasher_fin.update(&cr_msg).map_err(TlsError::CryptoError)?;
            hasher_fin
                .update(cert_msg_data)
                .map_err(TlsError::CryptoError)?;
            hasher_fin
                .finish(&mut fin_hash_buf)
                .map_err(TlsError::CryptoError)?;

            let (ct3, fin_data) = self.read_record()?;
            if ct3 != ContentType::Handshake {
                return Err(TlsError::HandshakeFailed(format!(
                    "expected Handshake (Finished), got {ct3:?}"
                )));
            }
            let (hs_type3, fin_body, _) = parse_handshake_header(&fin_data)?;
            if hs_type3 != HandshakeType::Finished {
                return Err(TlsError::HandshakeFailed(format!(
                    "expected Finished, got {hs_type3:?}"
                )));
            }
            let fin_msg = decode_finished(fin_body, params.hash_len)?;

            // Verify Finished
            let finished_key = ks.derive_finished_key(&self.client_app_secret)?;
            let expected = ks.compute_finished_verify_data(&finished_key, &fin_hash_buf)?;
            if fin_msg.verify_data != expected {
                return Err(TlsError::HandshakeFailed(
                    "post-HS client Finished verification failed".into(),
                ));
            }

            return Ok(client_certs);
        }

        // Read CertificateVerify
        let (ct2, cv_data) = self.read_record()?;
        if ct2 != ContentType::Handshake {
            return Err(TlsError::HandshakeFailed(format!(
                "expected Handshake (CertificateVerify), got {ct2:?}"
            )));
        }
        let (hs_type2, cv_body, cv_total) = parse_handshake_header(&cv_data)?;
        if hs_type2 != HandshakeType::CertificateVerify {
            return Err(TlsError::HandshakeFailed(format!(
                "expected CertificateVerify, got {hs_type2:?}"
            )));
        }
        let cv_msg_data = &cv_data[..cv_total];
        let cv_msg = decode_certificate_verify(cv_body)?;

        // Verify CertificateVerify signature against transcript hash
        let mut cv_hash = vec![0u8; params.hash_len];
        let mut hasher_cv = DigestVariant::new(alg);
        hasher_cv.update(&cr_msg).map_err(TlsError::CryptoError)?;
        hasher_cv
            .update(cert_msg_data)
            .map_err(TlsError::CryptoError)?;
        hasher_cv
            .finish(&mut cv_hash)
            .map_err(TlsError::CryptoError)?;

        // Parse the first client cert to verify the signature
        let client_cert = hitls_pki::x509::Certificate::from_der(&client_certs[0])
            .map_err(|e| TlsError::HandshakeFailed(format!("client cert parse: {e}")))?;
        verify_certificate_verify(
            &client_cert,
            cv_msg.algorithm,
            &cv_msg.signature,
            &cv_hash,
            false, // client CertificateVerify
        )?;

        // Update transcript with CertificateVerify, then compute hash for Finished
        hasher
            .update(cert_msg_data)
            .map_err(TlsError::CryptoError)?;
        // We need a fresh hasher for the Finished hash that includes CR+Cert+CV
        let mut fin_hash_buf = vec![0u8; params.hash_len];
        let mut hasher_fin = DigestVariant::new(alg);
        hasher_fin.update(&cr_msg).map_err(TlsError::CryptoError)?;
        hasher_fin
            .update(cert_msg_data)
            .map_err(TlsError::CryptoError)?;
        hasher_fin
            .update(cv_msg_data)
            .map_err(TlsError::CryptoError)?;
        hasher_fin
            .finish(&mut fin_hash_buf)
            .map_err(TlsError::CryptoError)?;

        // Read Finished
        let (ct3, fin_data) = self.read_record()?;
        if ct3 != ContentType::Handshake {
            return Err(TlsError::HandshakeFailed(format!(
                "expected Handshake (Finished), got {ct3:?}"
            )));
        }
        let (hs_type3, fin_body, _) = parse_handshake_header(&fin_data)?;
        if hs_type3 != HandshakeType::Finished {
            return Err(TlsError::HandshakeFailed(format!(
                "expected Finished, got {hs_type3:?}"
            )));
        }
        let fin_msg = decode_finished(fin_body, params.hash_len)?;

        // Verify Finished
        let finished_key = ks.derive_finished_key(&self.client_app_secret)?;
        let expected = ks.compute_finished_verify_data(&finished_key, &fin_hash_buf)?;
        if fin_msg.verify_data != expected {
            return Err(TlsError::HandshakeFailed(
                "post-HS client Finished verification failed".into(),
            ));
        }

        Ok(client_certs)
    }

    fn do_handshake(&mut self) -> Result<(), TlsError> {
        tls13_server_do_handshake_body!(sync, self)
    }
}

impl<S: Read + Write> TlsConnection for TlsServerConnection<S> {
    fn handshake(&mut self) -> Result<(), TlsError> {
        tls13_server_handshake_trait_body!(sync, self)
    }

    fn read(&mut self, buf: &mut [u8]) -> Result<usize, TlsError> {
        tls13_server_read_trait_body!(sync, self, buf)
    }

    fn write(&mut self, buf: &[u8]) -> Result<usize, TlsError> {
        tls_write_trait_body!(sync, self, buf)
    }

    fn shutdown(&mut self) -> Result<(), TlsError> {
        tls13_client_shutdown_trait_body!(sync, self)
    }

    fn version(&self) -> Option<TlsVersion> {
        self.negotiated_version
    }

    fn cipher_suite(&self) -> Option<CipherSuite> {
        self.negotiated_suite
    }
}
