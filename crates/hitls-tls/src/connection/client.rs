use std::io::{Read, Write};

use super::ConnectionState;
use crate::config::TlsConfig;
use crate::connection_info::ConnectionInfo;
use crate::crypt::key_schedule::KeySchedule;
use crate::crypt::traffic_keys::TrafficKeys;
use crate::crypt::{CipherSuiteParams, DigestVariant, NamedGroup};
use crate::handshake::client::{ClientHandshake, ServerHelloResult};
use crate::handshake::codec::{
    decode_certificate_request, decode_key_update, encode_certificate, encode_certificate_verify,
    encode_finished, encode_key_update, parse_handshake_header, CertificateEntry, CertificateMsg,
    CertificateVerifyMsg, KeyUpdateMsg, KeyUpdateRequest,
};
use crate::handshake::{HandshakeState, HandshakeType};
use crate::record::{ContentType, RecordLayer};
use crate::session::TlsSession;
use crate::{CipherSuite, TlsConnection, TlsError, TlsVersion};
use hitls_crypto::provider::Digest;
use zeroize::Zeroize;

/// A synchronous TLS 1.3 client connection.
pub struct TlsClientConnection<S: Read + Write> {
    stream: S,
    config: TlsConfig,
    record_layer: RecordLayer,
    pub(super) state: ConnectionState,
    negotiated_suite: Option<CipherSuite>,
    negotiated_version: Option<TlsVersion>,
    /// Buffer for reading records from the stream.
    read_buf: Vec<u8>,
    /// Buffered decrypted application data.
    app_data_buf: Vec<u8>,
    /// Cipher suite parameters (for key updates).
    pub(super) cipher_params: Option<CipherSuiteParams>,
    /// Client application traffic secret (for key updates).
    pub(super) client_app_secret: Vec<u8>,
    /// Server application traffic secret (for key updates).
    pub(super) server_app_secret: Vec<u8>,
    /// Resumption master secret (for processing NewSessionTicket).
    resumption_master_secret: Vec<u8>,
    /// Exporter master secret (for RFC 5705 / RFC 8446 ยง7.5 key material export).
    exporter_master_secret: Vec<u8>,
    /// Early exporter master secret (for 0-RTT key material export, empty if no PSK).
    pub(super) early_exporter_master_secret: Vec<u8>,
    /// Client handshake state (kept for processing post-handshake messages).
    client_hs: Option<ClientHandshake>,
    /// Received session from NewSessionTicket (for resumption).
    received_session: Option<TlsSession>,
    /// Early data to send during 0-RTT (queued before handshake).
    pub(super) early_data_queue: Vec<u8>,
    /// Whether early data was accepted by the server in this connection.
    early_data_accepted: bool,
    /// Peer certificates (DER-encoded, leaf first).
    peer_certificates: Vec<Vec<u8>>,
    /// Negotiated ALPN protocol (if any).
    negotiated_alpn: Option<Vec<u8>>,
    /// Server name (SNI) used in this connection.
    server_name_used: Option<String>,
    /// Negotiated key exchange group (if applicable).
    negotiated_group: Option<NamedGroup>,
    /// Whether this connection was resumed from a previous session.
    session_resumed: bool,
    /// Whether we have sent close_notify.
    sent_close_notify: bool,
    /// Whether we have received close_notify.
    received_close_notify: bool,
    /// Counter for consecutive KeyUpdate messages without application data.
    pub(super) key_update_recv_count: u32,
}

impl<S: Read + Write> Drop for TlsClientConnection<S> {
    fn drop(&mut self) {
        self.client_app_secret.zeroize();
        self.server_app_secret.zeroize();
        self.resumption_master_secret.zeroize();
        self.exporter_master_secret.zeroize();
        self.early_exporter_master_secret.zeroize();
    }
}

// Non-I/O accessor methods generated by macro.
impl_tls13_client_accessors!(TlsClientConnection, ConnectionState, Read + Write);

impl<S: Read + Write> TlsClientConnection<S> {
    /// Create a new TLS client connection wrapping the given stream.
    pub fn new(stream: S, config: TlsConfig) -> Self {
        Self {
            stream,
            config,
            record_layer: RecordLayer::new(),
            state: ConnectionState::Handshaking,
            negotiated_suite: None,
            negotiated_version: None,
            read_buf: Vec::with_capacity(16 * 1024),
            app_data_buf: Vec::new(),
            cipher_params: None,
            client_app_secret: Vec::new(),
            server_app_secret: Vec::new(),
            resumption_master_secret: Vec::new(),
            exporter_master_secret: Vec::new(),
            early_exporter_master_secret: Vec::new(),
            client_hs: None,
            received_session: None,
            early_data_queue: Vec::new(),
            early_data_accepted: false,
            peer_certificates: Vec::new(),
            negotiated_alpn: None,
            server_name_used: None,
            negotiated_group: None,
            session_resumed: false,
            sent_close_notify: false,
            received_close_notify: false,
            key_update_recv_count: 0,
        }
    }

    fn fill_buf(&mut self, min_bytes: usize) -> Result<(), TlsError> {
        fill_buf_body!(sync, self, min_bytes)
    }

    fn read_record(&mut self) -> Result<(ContentType, Vec<u8>), TlsError> {
        read_record_body!(sync, self)
    }

    /// Initiate a key update (RFC 8446 ยง4.6.3).
    pub fn key_update(&mut self, request_response: bool) -> Result<(), TlsError> {
        tls13_client_key_update_body!(sync, self, request_response)
    }

    fn handle_key_update(&mut self, body: &[u8]) -> Result<(), TlsError> {
        tls13_client_handle_key_update_body!(sync, self, body)
    }

    /// Handle a post-handshake CertificateRequest from the server (RFC 8446 ยง4.6.2).
    pub(super) fn handle_post_hs_cert_request(
        &mut self,
        body: &[u8],
        full_msg: &[u8],
    ) -> Result<(), TlsError> {
        tls13_client_handle_post_hs_cert_request_body!(sync, self, body, full_msg)
    }

    fn do_handshake(&mut self) -> Result<(), TlsError> {
        tls13_client_do_handshake_body!(sync, self)
    }

    fn read_and_process_server_hello(
        &mut self,
        hs: &mut ClientHandshake,
    ) -> Result<crate::handshake::client::ServerHelloActions, TlsError> {
        tls13_client_read_and_process_server_hello_body!(sync, self, hs)
    }

    fn process_encrypted_flight(
        &mut self,
        hs: &mut ClientHandshake,
        offered_early_data: bool,
        hs_write_suite: CipherSuite,
        hs_write_keys: &TrafficKeys,
    ) -> Result<(), TlsError> {
        tls13_client_process_encrypted_flight_body!(
            sync,
            self,
            hs,
            offered_early_data,
            hs_write_suite,
            hs_write_keys
        )
    }
}

impl<S: Read + Write> TlsConnection for TlsClientConnection<S> {
    fn handshake(&mut self) -> Result<(), TlsError> {
        tls13_client_handshake_trait_body!(sync, self)
    }

    fn read(&mut self, buf: &mut [u8]) -> Result<usize, TlsError> {
        tls13_client_read_trait_body!(sync, self, buf)
    }

    fn write(&mut self, buf: &[u8]) -> Result<usize, TlsError> {
        tls_write_trait_body!(sync, self, buf)
    }

    fn shutdown(&mut self) -> Result<(), TlsError> {
        tls13_client_shutdown_trait_body!(sync, self)
    }

    fn version(&self) -> Option<TlsVersion> {
        self.negotiated_version
    }

    fn cipher_suite(&self) -> Option<CipherSuite> {
        self.negotiated_suite
    }
}
